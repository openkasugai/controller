diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.c a/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
index 1e3eb120..ca37df1a 100644
--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
+++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
@@ -1,3 +1,7 @@
+/*****************************************************************
+ * Copyright 2024 NTT Corporation, FUJITSU LIMITED
+ *****************************************************************/
+
 /* GStreamer
  * Copyright (C) 2024 FIXME <fixme@example.com>
  *
@@ -34,9 +38,17 @@
 #include "config.h"
 #endif
 
+#define _GNU_SOURCE
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
 #include <gst/gst.h>
 #include <gst/base/gstbasesrc.h>
 #include "gstfpgasrc.h"
+#include "liblogging.h"
+#include "lib_worker.h"
 
 GST_DEBUG_CATEGORY_STATIC (gst_fpgasrc_debug_category);
 #define GST_CAT_DEFAULT gst_fpgasrc_debug_category
@@ -79,7 +91,11 @@ static GstFlowReturn gst_fpgasrc_fill (GstBaseSrc * src, guint64 offset,
 
 enum
 {
-  PROP_0
+  PROP_0,
+  PROP_USE_FPGA,
+  PROP_CONFIG_FPGA,
+  PROP_CHID,
+  PROP_DEQTCORE
 };
 
 /* pad templates */
@@ -88,9 +104,18 @@ static GstStaticPadTemplate gst_fpgasrc_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("application/unknown")
+    GST_STATIC_CAPS ("video/x-raw(ANY)")
     );
 
+extern struct data_size ds;
+static char* fpga_dev;
+static char* file_prefix;
+char* connector_id;
+bool debug_mode = false;
+int ch_num;
+static int ch_id;
+static int cpu_id;
+bool shmem_secondary = false;
 
 /* class initialization */
 
@@ -117,14 +142,17 @@ gst_fpgasrc_class_init (GstFpgasrcClass * klass)
   gobject_class->get_property = gst_fpgasrc_get_property;
   gobject_class->dispose = gst_fpgasrc_dispose;
   gobject_class->finalize = gst_fpgasrc_finalize;
+#if 0
   base_src_class->get_caps = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_caps);
   base_src_class->negotiate = GST_DEBUG_FUNCPTR (gst_fpgasrc_negotiate);
   base_src_class->fixate = GST_DEBUG_FUNCPTR (gst_fpgasrc_fixate);
   base_src_class->set_caps = GST_DEBUG_FUNCPTR (gst_fpgasrc_set_caps);
   base_src_class->decide_allocation = GST_DEBUG_FUNCPTR (gst_fpgasrc_decide_allocation);
+#endif
   base_src_class->start = GST_DEBUG_FUNCPTR (gst_fpgasrc_start);
   base_src_class->stop = GST_DEBUG_FUNCPTR (gst_fpgasrc_stop);
   base_src_class->get_times = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_times);
+#if 0
   base_src_class->get_size = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_size);
   base_src_class->is_seekable = GST_DEBUG_FUNCPTR (gst_fpgasrc_is_seekable);
   base_src_class->prepare_seek_segment = GST_DEBUG_FUNCPTR (gst_fpgasrc_prepare_seek_segment);
@@ -135,13 +163,73 @@ gst_fpgasrc_class_init (GstFpgasrcClass * klass)
   base_src_class->event = GST_DEBUG_FUNCPTR (gst_fpgasrc_event);
   base_src_class->create = GST_DEBUG_FUNCPTR (gst_fpgasrc_create);
   base_src_class->alloc = GST_DEBUG_FUNCPTR (gst_fpgasrc_alloc);
+#endif
   base_src_class->fill = GST_DEBUG_FUNCPTR (gst_fpgasrc_fill);
 
+  /* define properties */
+  g_object_class_install_property (gobject_class, PROP_USE_FPGA,
+  g_param_spec_boolean ("use-fpga", "USE-FPGA",
+			"Whether to use FPGA or not",
+			FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_CONFIG_FPGA,
+  g_param_spec_boolean ("config-fpga", "CONFIG-FPGA",
+			"Whether to configure FPGA or not",
+			FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_class, PROP_CHID,
+  g_param_spec_int ("chid", "CHID",
+		    "DMA channel ID",
+		    0, 15, 0, G_PARAM_READWRITE));
+  g_object_class_install_property (gobject_class, PROP_DEQTCORE,
+  g_param_spec_int ("deqtcore", "DEQTCORE",
+		    "CPU core to run dequeue thread on",
+		    0, 31, 0, G_PARAM_READWRITE));
 }
 
 static void
 gst_fpgasrc_init (GstFpgasrc *fpgasrc)
 {
+  gst_base_src_set_format (GST_BASE_SRC (fpgasrc), GST_FORMAT_TIME);
+  gst_base_src_set_live (GST_BASE_SRC (fpgasrc), true);
+
+  int ret;
+  int log_level;
+  char *strenv;
+  strenv = getenv("LOG_LEVEL");
+  if (strenv == NULL) {
+    log_level = LIBFPGA_LOG_INFO;
+  } else {
+    log_level = atoi(strenv);
+  }
+  libfpga_log_set_level(log_level);
+
+  strenv = getenv("FILE_PREFIX");
+  if (strenv == NULL) {
+    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FILE_PREFIX must be specified\n");
+  }
+  file_prefix = strenv;
+
+  strenv = getenv("SHMEM_SECONDARY");
+  if (strenv != NULL && strcmp(strenv, "1") == 0) {
+    log_libfpga(LIBFPGA_LOG_INFO,"start shmem secondary mode\n");
+    shmem_secondary = true;
+  }
+
+  cpu_set_t mask;
+  size_t len = sizeof(mask);
+  pid_t tid = gettid();
+  CPU_ZERO(&mask);
+  ret = sched_getaffinity(0, len, &mask);
+  assert(ret == 0);
+
+  ret = init_mem(file_prefix, shmem_secondary);
+  if (ret < 0) {
+    log_libfpga(LIBFPGA_LOG_ERROR, "init_mem failed ret=%d\n", ret);
+    exit(EXIT_FAILURE);
+  }
+
+  /* restore CPU mask */
+  ret = sched_setaffinity(0, len, &mask);
+  assert(ret == 0);
 }
 
 void
@@ -153,7 +241,27 @@ gst_fpgasrc_set_property (GObject * object, guint property_id,
   GST_DEBUG_OBJECT (fpgasrc, "set_property");
 
   switch (property_id) {
-    default:
+  case PROP_USE_FPGA:
+      fpgasrc->use_fpga = g_value_get_boolean (value);
+      g_print ("use-fpga argument was changed to %s\n",
+           fpgasrc->use_fpga ? "true" : "false");
+      break;
+  case PROP_CONFIG_FPGA:
+      fpgasrc->config_fpga = g_value_get_boolean (value);
+      g_print ("config-fpga argument was changed to %s\n",
+           fpgasrc->config_fpga ? "true" : "false");
+      break;
+  case PROP_CHID:
+      fpgasrc->chid = g_value_get_int (value);
+      g_print ("chid argument was changed to %u\n",
+           fpgasrc->chid);
+      break;
+  case PROP_DEQTCORE:
+      fpgasrc->deqtcore = g_value_get_int (value);
+      g_print ("deqtcore argument was changed to %u\n",
+           fpgasrc->deqtcore);
+      break;
+  default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
   }
@@ -168,7 +276,19 @@ gst_fpgasrc_get_property (GObject * object, guint property_id,
   GST_DEBUG_OBJECT (fpgasrc, "get_property");
 
   switch (property_id) {
-    default:
+  case PROP_USE_FPGA:
+      g_value_set_boolean (value, fpgasrc->use_fpga);
+      break;
+  case PROP_CONFIG_FPGA:
+      g_value_set_boolean (value, fpgasrc->config_fpga);
+      break;
+  case PROP_CHID:
+      g_value_set_int (value, fpgasrc->chid);
+      break;
+  case PROP_DEQTCORE:
+      g_value_set_int (value, fpgasrc->deqtcore);
+      break;
+  default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
   }
@@ -257,20 +377,129 @@ gst_fpgasrc_decide_allocation (GstBaseSrc * src, GstQuery * query)
 static gboolean
 gst_fpgasrc_start (GstBaseSrc * src)
 {
+  int ret;
+
+  log_libfpga(LIBFPGA_LOG_INFO, "%s: start\n", __FUNCTION__);
+
   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
 
   GST_DEBUG_OBJECT (fpgasrc, "start");
 
+  char *strenv;
+
+  // required environment variables
+
+  strenv = getenv("FPGA_DEV");
+  if (strenv == NULL) {
+    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FPGA_DEV must be specified\n");
+    return GST_FLOW_ERROR;
+  }
+  fpga_dev = strenv;
+
+  strenv = getenv("FILE_PREFIX");
+  if (strenv == NULL) {
+    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FILE_PREFIX must be specified\n");
+    return GST_FLOW_ERROR;
+  }
+  file_prefix = strenv;
+
+  strenv = getenv("HEIGHT");
+  if (strenv == NULL) {
+    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable HEIGHT must be specified\n");
+    return GST_FLOW_ERROR;
+  }
+  ds.output_height = atoi(strenv);
+
+  strenv = getenv("WIDTH");
+  if (strenv == NULL) {
+    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable WIDTH must be specified\n");
+    return GST_FLOW_ERROR;
+  }
+  ds.output_width = atoi(strenv);
+
+  // debug mode
+  strenv = getenv("DEBUG_MODE");
+  if (strenv != NULL && strcmp(strenv, "1") == 0) {
+    log_libfpga(LIBFPGA_LOG_INFO,"debug mode started\n");
+    debug_mode = true;
+    return TRUE;
+  }
+  strenv = getenv("CONNECTOR_ID");
+  if (strenv == NULL) {
+    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable CONNECTOR_ID must be specified in worker-mode\n");
+    return GST_FLOW_ERROR;
+  }
+  connector_id = strenv;
+
+  // optional environment variables
+
+  strenv = getenv("CPU_ID");
+  if (strenv == NULL) {
+    cpu_id = 0;
+  } else {
+    cpu_id = atoi(strenv);
+  }
+
+  char ch_num_str[3];
+  sprintf(ch_num_str, "%2d", 1);
+
+  // TODO: find free core
+  //char deqtcore_name[3];
+  //sprintf(deqtcore_name, "%2d", fpgasrc->deqtcore);
+
+  //GstClock clock;
+  //gst_element_set_clock (GST_ELEMENT(fpgasrc), &clock);
+
+  ret = init_worker(fpga_dev, file_prefix, connector_id);
+  if (ret < 0) {
+    return GST_FLOW_ERROR;
+  }
+  cpu_set_t mask;
+  size_t len = sizeof(mask);
+  pid_t tid = gettid();
+  CPU_ZERO(&mask);
+  CPU_SET(cpu_id, &mask);
+  ret = sched_setaffinity(0, len, &mask);
+  assert(ret == 0);
+  ret = sched_getaffinity(0, len, &mask);
+  assert(ret == 0);
+  log_libfpga(LIBFPGA_LOG_INFO, "tid %d's affinity = %08lx\n", tid, *(unsigned long*)mask.__bits);
+  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
+
+  fpgasrc->start_time = get_current_time();
+  fpgasrc->total_exec_time = 0;
+  fpgasrc->total_wait_time = 0;
+  for (int i = 0; i < DEBUG_TIMES; i++) {
+    fpgasrc->total_debug_times[i] = 0;
+  }
+  fpgasrc->prev_finish_time = 0;
+  fpgasrc->exec_count = 0;
   return TRUE;
 }
 
 static gboolean
 gst_fpgasrc_stop (GstBaseSrc * src)
 {
+  int ret;
+
+  if (debug_mode) {
+    log_libfpga(LIBFPGA_LOG_INFO, "debug mode finished\n");
+    return TRUE;
+  }
+
+  log_libfpga(LIBFPGA_LOG_INFO, "%s start\n", __FUNCTION__);
+
   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
 
   GST_DEBUG_OBJECT (fpgasrc, "stop");
 
+  ret = finish_worker();
+  if (ret < 0) {
+    return GST_FLOW_ERROR;
+  }
+
+  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
+
   return TRUE;
 }
 
@@ -282,6 +511,9 @@ gst_fpgasrc_get_times (GstBaseSrc * src, GstBuffer * buffer,
 {
   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
 
+  *start = GST_BUFFER_PTS(buffer);
+  *end = *start + GST_BUFFER_DURATION(buffer);
+
   GST_DEBUG_OBJECT (fpgasrc, "get_times");
 
 }
@@ -403,14 +635,142 @@ gst_fpgasrc_alloc (GstBaseSrc * src, guint64 offset, guint size,
   return GST_FLOW_OK;
 }
 
+struct callback_info {
+  uint32_t cmd_idx;
+};
+
+static void callback(void* data) {
+  int rc;
+  struct callback_info* ci = (struct callback_info*)data;
+  log_libfpga (LIBFPGA_LOG_DEBUG, "%s: cmd_idx=%u\n", __FUNCTION__, ci->cmd_idx);
+  rc = clear_buffer(ci->cmd_idx);
+  if (rc < 0) {
+    log_libfpga(LIBFPGA_LOG_WARN, "clear_buffer failed! ret=%d\n", rc);
+  }
+  free(data);
+}
+
+static void debug_callback(void* data) {
+  free(data);
+}
+
+static bool connected = false;
+static uint32_t cmd_idx = 0;
+//static uint64_t clock_count = 0;
+
 /* ask the subclass to fill the buffer with data from offset and size */
 static GstFlowReturn
 gst_fpgasrc_fill (GstBaseSrc * src, guint64 offset, guint size, GstBuffer * buf)
 {
+  log_libfpga(LIBFPGA_LOG_INFO, "%s: start\n", __FUNCTION__);
   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
 
   GST_DEBUG_OBJECT (fpgasrc, "fill");
 
+  GstClockTime start_time = get_current_time();
+  if (fpgasrc->prev_finish_time != 0) {
+    fpgasrc->total_wait_time += (start_time - fpgasrc->prev_finish_time);
+  }
+
+  int stats_interval = 10;
+  if (fpgasrc->exec_count > 0 && fpgasrc->exec_count % stats_interval == 0) {
+    log_libfpga(LIBFPGA_LOG_INFO, "stats: avg exec_time=%lu [ms],  avg wait_time=%lu [ms]\n",
+	   fpgasrc->total_exec_time/(stats_interval*1UL*1000*1000),
+	   fpgasrc->total_wait_time/(stats_interval*1UL*1000*1000)
+	   );
+    log_libfpga(LIBFPGA_LOG_INFO, "stats: avg read_buffer_time=%lu [ms]\n",
+	   fpgasrc->total_debug_times[0]/(stats_interval*1UL*1000*1000)
+	   );
+    fpgasrc->total_exec_time = 0;
+    fpgasrc->total_wait_time = 0;
+    for (int i = 0; i < DEBUG_TIMES; i++) {
+      fpgasrc->total_debug_times[i] = 0;
+    }
+  }
+
+  gst_buffer_remove_all_memory(buf);
+
+  int framerate = 30;
+  uint64_t interval_in_nanosecdonss = 1UL*1000*1000*1000 / framerate;
+
+  if (debug_mode) {
+
+    unsigned long time = 300;
+    if (start_time - fpgasrc->start_time > 1UL*1000*1000*1000*time ) {
+      log_libfpga(LIBFPGA_LOG_INFO, "written for %lu [sec] at %d [fps] in debug-mode!\n", time, framerate);
+      return GST_FLOW_EOS;
+    }
+    int size = ds.output_width * ds.output_height * 3;
+    void* data = malloc(size);
+    memset(data, 0xFF, size);
+    GstMemory *mem = gst_memory_new_wrapped(0, data, size, 0, size, data, debug_callback);
+    gst_buffer_append_memory(buf, mem);
+    log_libfpga(LIBFPGA_LOG_INFO, "debug_mode: data of size %d generated!\n", size);
+    usleep(interval_in_nanosecdonss/1000);
+    GstClockTime running_time = get_current_time() - fpgasrc->start_time;
+    //clock_count += interval_in_nanosecdonss;
+    GST_BUFFER_PTS(buf) = running_time;
+    GST_BUFFER_TIMESTAMP(buf) = running_time;
+    GST_BUFFER_DTS(buf) = GST_CLOCK_TIME_NONE;
+#if 0
+    GST_BUFFER_DURATION(buf) = interval_in_nanosecdonss;
+#endif
+    gst_object_sync_values (GST_OBJECT (fpgasrc), GST_BUFFER_PTS (buf));
+    return GST_FLOW_OK;
+  }
+
+  void* data;
+  int data_size;
+  int next_cmd_idx;
+  struct callback_info* ci;
+  unsigned long read_buffer_start_time = get_current_time();
+  next_cmd_idx = read_buffer(cmd_idx, &data, &data_size);
+  unsigned long read_buffer_finish_time = get_current_time();
+  fpgasrc->total_debug_times[0] += (read_buffer_finish_time - read_buffer_start_time);
+  if (next_cmd_idx == -1) {
+    // timeout
+    log_libfpga(LIBFPGA_LOG_WARN, "create dummy data, size = (%d, %d)\n", ds.output_width, ds.output_height);
+    int dummy_data_size = ds.output_width * ds.output_height * 3;
+    void* dummy_data = malloc(dummy_data_size);
+    memset(dummy_data, 0xFF, dummy_data_size);
+    GstMemory *mem = gst_memory_new_wrapped(0, dummy_data, dummy_data_size, 0, dummy_data_size, dummy_data, debug_callback);
+    gst_buffer_append_memory(buf, mem);
+  } else {
+    // received data
+    ci = malloc(sizeof(struct callback_info));
+    ci->cmd_idx = cmd_idx;
+    cmd_idx = next_cmd_idx;
+    if (data == NULL) {
+      log_libfpga(LIBFPGA_LOG_WARN, "create dummy data, size = (%d, %d)\n", ds.output_width, ds.output_height);
+      int dummy_data_size = ds.output_width * ds.output_height * 3;
+      void* dummy_data = malloc(dummy_data_size);
+      memset(dummy_data, 0x77, dummy_data_size);
+      GstMemory *mem = gst_memory_new_wrapped(0, dummy_data, dummy_data_size, 0, dummy_data_size, dummy_data, debug_callback);
+      gst_buffer_append_memory(buf, mem);
+      // discard broken data right away
+      callback((void*)ci);
+    } else {
+      GstMemory *mem = gst_memory_new_wrapped(0, data, data_size, 0, data_size, (void*)ci, callback);
+      gst_buffer_append_memory(buf, mem);
+    }
+  }
+  GstClockTime finish_time = get_current_time();
+  fpgasrc->total_exec_time += (finish_time - start_time);
+  fpgasrc->prev_finish_time = finish_time;
+  fpgasrc->exec_count++;
+
+  GstClockTime running_time = get_current_time() - fpgasrc->start_time;
+  //clock_count += interval_in_nanosecdonss;
+  GST_BUFFER_PTS(buf) = running_time;
+  GST_BUFFER_TIMESTAMP(buf) = running_time;
+  GST_BUFFER_DTS(buf) = GST_CLOCK_TIME_NONE;
+#if 0
+  GST_BUFFER_DURATION(buf) = interval_in_nanosecdonss;
+#endif
+  gst_object_sync_values (GST_OBJECT (fpgasrc), GST_BUFFER_PTS (buf));
+  
+  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
+
   return GST_FLOW_OK;
 }
 
diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.h a/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
index 33e20e32..eb33582a 100644
--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
+++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
@@ -1,3 +1,7 @@
+/*****************************************************************
+ * Copyright 2024 NTT Corporation, FUJITSU LIMITED
+ *****************************************************************/
+
 /* GStreamer
  * Copyright (C) 2024 FIXME <fixme@example.com>
  *
@@ -33,10 +37,22 @@ G_BEGIN_DECLS
 typedef struct _GstFpgasrc GstFpgasrc;
 typedef struct _GstFpgasrcClass GstFpgasrcClass;
 
+#define DEBUG_TIMES 10
+
 struct _GstFpgasrc
 {
   GstBaseSrc base_fpgasrc;
 
+  gboolean use_fpga;
+  gboolean config_fpga;
+  gint chid;
+  gint deqtcore;
+  GstClockTime start_time;
+  GstClockTime total_exec_time;
+  GstClockTime total_wait_time;
+  GstClockTime prev_finish_time;
+  GstClockTime total_debug_times[DEBUG_TIMES];
+  gint exec_count;
 };
 
 struct _GstFpgasrcClass
diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch a/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch
index da2ef67f..668880d6 100644
--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch
+++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch
@@ -0,0 +1,1056 @@
+diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.c a/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
+index 1e3eb120..87e06c1d 100644
+--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
++++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
+@@ -1,3 +1,7 @@
++/*****************************************************************
++ * Copyright 2024 NTT Corporation, FUJITSU LIMITED
++ *****************************************************************/
++
+ /* GStreamer
+  * Copyright (C) 2024 FIXME <fixme@example.com>
+  *
+@@ -34,9 +38,16 @@
+ #include "config.h"
+ #endif
+ 
++#define _GNU_SOURCE
++
++#include <assert.h>
++#include <stdio.h>
++
+ #include <gst/gst.h>
+ #include <gst/base/gstbasesrc.h>
+ #include "gstfpgasrc.h"
++#include "liblogging.h"
++#include "lib_worker.h"
+ 
+ GST_DEBUG_CATEGORY_STATIC (gst_fpgasrc_debug_category);
+ #define GST_CAT_DEFAULT gst_fpgasrc_debug_category
+@@ -79,7 +90,11 @@ static GstFlowReturn gst_fpgasrc_fill (GstBaseSrc * src, guint64 offset,
+ 
+ enum
+ {
+-  PROP_0
++  PROP_0,
++  PROP_USE_FPGA,
++  PROP_CONFIG_FPGA,
++  PROP_CHID,
++  PROP_DEQTCORE
+ };
+ 
+ /* pad templates */
+@@ -88,9 +103,19 @@ static GstStaticPadTemplate gst_fpgasrc_src_template =
+ GST_STATIC_PAD_TEMPLATE ("src",
+     GST_PAD_SRC,
+     GST_PAD_ALWAYS,
+-    GST_STATIC_CAPS ("application/unknown")
++    GST_STATIC_CAPS ("video/x-raw(ANY)")
+     );
+ 
++extern struct data_size ds;
++static char* fpga_dev;
++static char* file_prefix;
++static bool shmem_initialized = false;
++char* connector_id;
++bool debug_mode = false;
++int ch_num;
++static int ch_id;
++static int cpu_id;
++bool shmem_secondary = false;
+ 
+ /* class initialization */
+ 
+@@ -117,14 +142,17 @@ gst_fpgasrc_class_init (GstFpgasrcClass * klass)
+   gobject_class->get_property = gst_fpgasrc_get_property;
+   gobject_class->dispose = gst_fpgasrc_dispose;
+   gobject_class->finalize = gst_fpgasrc_finalize;
++#if 0
+   base_src_class->get_caps = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_caps);
+   base_src_class->negotiate = GST_DEBUG_FUNCPTR (gst_fpgasrc_negotiate);
+   base_src_class->fixate = GST_DEBUG_FUNCPTR (gst_fpgasrc_fixate);
+   base_src_class->set_caps = GST_DEBUG_FUNCPTR (gst_fpgasrc_set_caps);
+   base_src_class->decide_allocation = GST_DEBUG_FUNCPTR (gst_fpgasrc_decide_allocation);
++#endif
+   base_src_class->start = GST_DEBUG_FUNCPTR (gst_fpgasrc_start);
+   base_src_class->stop = GST_DEBUG_FUNCPTR (gst_fpgasrc_stop);
+   base_src_class->get_times = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_times);
++#if 0
+   base_src_class->get_size = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_size);
+   base_src_class->is_seekable = GST_DEBUG_FUNCPTR (gst_fpgasrc_is_seekable);
+   base_src_class->prepare_seek_segment = GST_DEBUG_FUNCPTR (gst_fpgasrc_prepare_seek_segment);
+@@ -135,13 +163,74 @@ gst_fpgasrc_class_init (GstFpgasrcClass * klass)
+   base_src_class->event = GST_DEBUG_FUNCPTR (gst_fpgasrc_event);
+   base_src_class->create = GST_DEBUG_FUNCPTR (gst_fpgasrc_create);
+   base_src_class->alloc = GST_DEBUG_FUNCPTR (gst_fpgasrc_alloc);
++#endif
+   base_src_class->fill = GST_DEBUG_FUNCPTR (gst_fpgasrc_fill);
+ 
++  /* define properties */
++  g_object_class_install_property (gobject_class, PROP_USE_FPGA,
++  g_param_spec_boolean ("use-fpga", "USE-FPGA",
++			"Whether to use FPGA or not",
++			FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
++  g_object_class_install_property (gobject_class, PROP_CONFIG_FPGA,
++  g_param_spec_boolean ("config-fpga", "CONFIG-FPGA",
++			"Whether to configure FPGA or not",
++			FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
++  g_object_class_install_property (gobject_class, PROP_CHID,
++  g_param_spec_int ("chid", "CHID",
++		    "DMA channel ID",
++		    0, 15, 0, G_PARAM_READWRITE));
++  g_object_class_install_property (gobject_class, PROP_DEQTCORE,
++  g_param_spec_int ("deqtcore", "DEQTCORE",
++		    "CPU core to run dequeue thread on",
++		    0, 31, 0, G_PARAM_READWRITE));
+ }
+ 
+ static void
+ gst_fpgasrc_init (GstFpgasrc *fpgasrc)
+ {
++  gst_base_src_set_format (GST_BASE_SRC (fpgasrc), GST_FORMAT_TIME);
++  gst_base_src_set_live (GST_BASE_SRC (fpgasrc), true);
++
++  int ret;
++  int log_level;
++  char *strenv;
++  strenv = getenv("LOG_LEVEL");
++  if (strenv == NULL) {
++    log_level = LIBFPGA_LOG_INFO;
++  } else {
++    log_level = atoi(strenv);
++  }
++  libfpga_log_set_level(log_level);
++
++  strenv = getenv("FILE_PREFIX");
++  if (strenv == NULL) {
++    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FILE_PREFIX must be specified\n");
++  }
++  file_prefix = strenv;
++
++  strenv = getenv("SHMEM_SECONDARY");
++  if (strenv != NULL && strcmp(strenv, "1") == 0) {
++    log_libfpga(LIBFPGA_LOG_INFO,"start shmem secondary mode\n");
++    shmem_secondary = true;
++  }
++
++  cpu_set_t mask;
++  size_t len = sizeof(mask);
++  pid_t tid = gettid();
++  CPU_ZERO(&mask);
++  ret = sched_getaffinity(0, len, &mask);
++  assert(ret == 0);
++
++  ret = init_mem(file_prefix, shmem_secondary);
++  if (ret < 0) {
++    log_libfpga(LIBFPGA_LOG_ERROR, "init_mem failed ret=%d\n", ret);
++    return;
++  }
++  shmem_initialized = true;
++
++  /* restore CPU mask */
++  ret = sched_setaffinity(0, len, &mask);
++  assert(ret == 0);
+ }
+ 
+ void
+@@ -153,7 +242,27 @@ gst_fpgasrc_set_property (GObject * object, guint property_id,
+   GST_DEBUG_OBJECT (fpgasrc, "set_property");
+ 
+   switch (property_id) {
+-    default:
++  case PROP_USE_FPGA:
++      fpgasrc->use_fpga = g_value_get_boolean (value);
++      g_print ("use-fpga argument was changed to %s\n",
++           fpgasrc->use_fpga ? "true" : "false");
++      break;
++  case PROP_CONFIG_FPGA:
++      fpgasrc->config_fpga = g_value_get_boolean (value);
++      g_print ("config-fpga argument was changed to %s\n",
++           fpgasrc->config_fpga ? "true" : "false");
++      break;
++  case PROP_CHID:
++      fpgasrc->chid = g_value_get_int (value);
++      g_print ("chid argument was changed to %u\n",
++           fpgasrc->chid);
++      break;
++  case PROP_DEQTCORE:
++      fpgasrc->deqtcore = g_value_get_int (value);
++      g_print ("deqtcore argument was changed to %u\n",
++           fpgasrc->deqtcore);
++      break;
++  default:
+       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+       break;
+   }
+@@ -168,7 +277,19 @@ gst_fpgasrc_get_property (GObject * object, guint property_id,
+   GST_DEBUG_OBJECT (fpgasrc, "get_property");
+ 
+   switch (property_id) {
+-    default:
++  case PROP_USE_FPGA:
++      g_value_set_boolean (value, fpgasrc->use_fpga);
++      break;
++  case PROP_CONFIG_FPGA:
++      g_value_set_boolean (value, fpgasrc->config_fpga);
++      break;
++  case PROP_CHID:
++      g_value_set_int (value, fpgasrc->chid);
++      break;
++  case PROP_DEQTCORE:
++      g_value_set_int (value, fpgasrc->deqtcore);
++      break;
++  default:
+       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
+       break;
+   }
+@@ -257,20 +378,134 @@ gst_fpgasrc_decide_allocation (GstBaseSrc * src, GstQuery * query)
+ static gboolean
+ gst_fpgasrc_start (GstBaseSrc * src)
+ {
++  int ret;
++
++  if (!shmem_initialized) {
++    log_libfpga(LIBFPGA_LOG_ERROR, "DPDK not initialized\n");
++    return GST_FLOW_ERROR;
++  }
++
++  log_libfpga(LIBFPGA_LOG_INFO, "%s: start\n", __FUNCTION__);
++
+   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
+ 
+   GST_DEBUG_OBJECT (fpgasrc, "start");
+ 
++  char *strenv;
++
++  // required environment variables
++
++  strenv = getenv("FPGA_DEV");
++  if (strenv == NULL) {
++    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FPGA_DEV must be specified\n");
++    return GST_FLOW_ERROR;
++  }
++  fpga_dev = strenv;
++
++  strenv = getenv("FILE_PREFIX");
++  if (strenv == NULL) {
++    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FILE_PREFIX must be specified\n");
++    return GST_FLOW_ERROR;
++  }
++  file_prefix = strenv;
++
++  strenv = getenv("HEIGHT");
++  if (strenv == NULL) {
++    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable HEIGHT must be specified\n");
++    return GST_FLOW_ERROR;
++  }
++  ds.output_height = atoi(strenv);
++
++  strenv = getenv("WIDTH");
++  if (strenv == NULL) {
++    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable WIDTH must be specified\n");
++    return GST_FLOW_ERROR;
++  }
++  ds.output_width = atoi(strenv);
++
++  // debug mode
++  strenv = getenv("DEBUG_MODE");
++  if (strenv != NULL && strcmp(strenv, "1") == 0) {
++    log_libfpga(LIBFPGA_LOG_INFO,"debug mode started\n");
++    debug_mode = true;
++    return TRUE;
++  }
++  strenv = getenv("CONNECTOR_ID");
++  if (strenv == NULL) {
++    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable CONNECTOR_ID must be specified in worker-mode\n");
++    return GST_FLOW_ERROR;
++  }
++  connector_id = strenv;
++
++  // optional environment variables
++
++  strenv = getenv("CPU_ID");
++  if (strenv == NULL) {
++    cpu_id = 0;
++  } else {
++    cpu_id = atoi(strenv);
++  }
++
++  char ch_num_str[3];
++  sprintf(ch_num_str, "%2d", 1);
++
++  // TODO: find free core
++  //char deqtcore_name[3];
++  //sprintf(deqtcore_name, "%2d", fpgasrc->deqtcore);
++
++  //GstClock clock;
++  //gst_element_set_clock (GST_ELEMENT(fpgasrc), &clock);
++
++  ret = init_worker(fpga_dev, file_prefix, connector_id);
++  if (ret < 0) {
++    return GST_FLOW_ERROR;
++  }
++  cpu_set_t mask;
++  size_t len = sizeof(mask);
++  pid_t tid = gettid();
++  CPU_ZERO(&mask);
++  CPU_SET(cpu_id, &mask);
++  ret = sched_setaffinity(0, len, &mask);
++  assert(ret == 0);
++  ret = sched_getaffinity(0, len, &mask);
++  assert(ret == 0);
++  log_libfpga(LIBFPGA_LOG_INFO, "tid %d's affinity = %08lx\n", tid, *(unsigned long*)mask.__bits);
++  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
++
++  fpgasrc->start_time = get_current_time();
++  fpgasrc->total_exec_time = 0;
++  fpgasrc->total_wait_time = 0;
++  for (int i = 0; i < DEBUG_TIMES; i++) {
++    fpgasrc->total_debug_times[i] = 0;
++  }
++  fpgasrc->prev_finish_time = 0;
++  fpgasrc->exec_count = 0;
+   return TRUE;
+ }
+ 
+ static gboolean
+ gst_fpgasrc_stop (GstBaseSrc * src)
+ {
++  int ret;
++
++  if (debug_mode) {
++    log_libfpga(LIBFPGA_LOG_INFO, "debug mode finished\n");
++    return TRUE;
++  }
++
++  log_libfpga(LIBFPGA_LOG_INFO, "%s start\n", __FUNCTION__);
++
+   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
+ 
+   GST_DEBUG_OBJECT (fpgasrc, "stop");
+ 
++  ret = finish_worker();
++  if (ret < 0) {
++    return GST_FLOW_ERROR;
++  }
++
++  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
++
+   return TRUE;
+ }
+ 
+@@ -282,6 +517,9 @@ gst_fpgasrc_get_times (GstBaseSrc * src, GstBuffer * buffer,
+ {
+   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
+ 
++  *start = GST_BUFFER_PTS(buffer);
++  *end = *start + GST_BUFFER_DURATION(buffer);
++
+   GST_DEBUG_OBJECT (fpgasrc, "get_times");
+ 
+ }
+@@ -403,14 +641,142 @@ gst_fpgasrc_alloc (GstBaseSrc * src, guint64 offset, guint size,
+   return GST_FLOW_OK;
+ }
+ 
++struct callback_info {
++  uint32_t cmd_idx;
++};
++
++static void callback(void* data) {
++  int rc;
++  struct callback_info* ci = (struct callback_info*)data;
++  log_libfpga (LIBFPGA_LOG_DEBUG, "%s: cmd_idx=%u\n", __FUNCTION__, ci->cmd_idx);
++  rc = clear_buffer(ci->cmd_idx);
++  if (rc < 0) {
++    log_libfpga(LIBFPGA_LOG_WARN, "clear_buffer failed! ret=%d\n", rc);
++  }
++  free(data);
++}
++
++static void debug_callback(void* data) {
++  free(data);
++}
++
++static bool connected = false;
++static uint32_t cmd_idx = 0;
++//static uint64_t clock_count = 0;
++
+ /* ask the subclass to fill the buffer with data from offset and size */
+ static GstFlowReturn
+ gst_fpgasrc_fill (GstBaseSrc * src, guint64 offset, guint size, GstBuffer * buf)
+ {
++  log_libfpga(LIBFPGA_LOG_INFO, "%s: start\n", __FUNCTION__);
+   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
+ 
+   GST_DEBUG_OBJECT (fpgasrc, "fill");
+ 
++  GstClockTime start_time = get_current_time();
++  if (fpgasrc->prev_finish_time != 0) {
++    fpgasrc->total_wait_time += (start_time - fpgasrc->prev_finish_time);
++  }
++
++  int stats_interval = 10;
++  if (fpgasrc->exec_count > 0 && fpgasrc->exec_count % stats_interval == 0) {
++    log_libfpga(LIBFPGA_LOG_INFO, "stats: avg exec_time=%lu [ms],  avg wait_time=%lu [ms]\n",
++	   fpgasrc->total_exec_time/(stats_interval*1UL*1000*1000),
++	   fpgasrc->total_wait_time/(stats_interval*1UL*1000*1000)
++	   );
++    log_libfpga(LIBFPGA_LOG_INFO, "stats: avg read_buffer_time=%lu [ms]\n",
++	   fpgasrc->total_debug_times[0]/(stats_interval*1UL*1000*1000)
++	   );
++    fpgasrc->total_exec_time = 0;
++    fpgasrc->total_wait_time = 0;
++    for (int i = 0; i < DEBUG_TIMES; i++) {
++      fpgasrc->total_debug_times[i] = 0;
++    }
++  }
++
++  gst_buffer_remove_all_memory(buf);
++
++  int framerate = 30;
++  uint64_t interval_in_nanosecdonss = 1UL*1000*1000*1000 / framerate;
++
++  if (debug_mode) {
++
++    unsigned long time = 300;
++    if (start_time - fpgasrc->start_time > 1UL*1000*1000*1000*time ) {
++      log_libfpga(LIBFPGA_LOG_INFO, "written for %lu [sec] at %d [fps] in debug-mode!\n", time, framerate);
++      return GST_FLOW_EOS;
++    }
++    int size = ds.output_width * ds.output_height * 3;
++    void* data = malloc(size);
++    memset(data, 0xFF, size);
++    GstMemory *mem = gst_memory_new_wrapped(0, data, size, 0, size, data, debug_callback);
++    gst_buffer_append_memory(buf, mem);
++    log_libfpga(LIBFPGA_LOG_INFO, "debug_mode: data of size %d generated!\n", size);
++    usleep(interval_in_nanosecdonss/1000);
++    GstClockTime running_time = get_current_time() - fpgasrc->start_time;
++    //clock_count += interval_in_nanosecdonss;
++    GST_BUFFER_PTS(buf) = running_time;
++    GST_BUFFER_TIMESTAMP(buf) = running_time;
++    GST_BUFFER_DTS(buf) = GST_CLOCK_TIME_NONE;
++#if 0
++    GST_BUFFER_DURATION(buf) = interval_in_nanosecdonss;
++#endif
++    gst_object_sync_values (GST_OBJECT (fpgasrc), GST_BUFFER_PTS (buf));
++    return GST_FLOW_OK;
++  }
++
++  void* data;
++  int data_size;
++  int next_cmd_idx;
++  struct callback_info* ci;
++  unsigned long read_buffer_start_time = get_current_time();
++  next_cmd_idx = read_buffer(cmd_idx, &data, &data_size);
++  unsigned long read_buffer_finish_time = get_current_time();
++  fpgasrc->total_debug_times[0] += (read_buffer_finish_time - read_buffer_start_time);
++  if (next_cmd_idx == -1) {
++    // timeout
++    log_libfpga(LIBFPGA_LOG_WARN, "create dummy data, size = (%d, %d)\n", ds.output_width, ds.output_height);
++    int dummy_data_size = ds.output_width * ds.output_height * 3;
++    void* dummy_data = malloc(dummy_data_size);
++    memset(dummy_data, 0xFF, dummy_data_size);
++    GstMemory *mem = gst_memory_new_wrapped(0, dummy_data, dummy_data_size, 0, dummy_data_size, dummy_data, debug_callback);
++    gst_buffer_append_memory(buf, mem);
++  } else {
++    // received data
++    ci = malloc(sizeof(struct callback_info));
++    ci->cmd_idx = cmd_idx;
++    cmd_idx = next_cmd_idx;
++    if (data == NULL) {
++      log_libfpga(LIBFPGA_LOG_WARN, "create dummy data, size = (%d, %d)\n", ds.output_width, ds.output_height);
++      int dummy_data_size = ds.output_width * ds.output_height * 3;
++      void* dummy_data = malloc(dummy_data_size);
++      memset(dummy_data, 0x77, dummy_data_size);
++      GstMemory *mem = gst_memory_new_wrapped(0, dummy_data, dummy_data_size, 0, dummy_data_size, dummy_data, debug_callback);
++      gst_buffer_append_memory(buf, mem);
++      // discard broken data right away
++      callback((void*)ci);
++    } else {
++      GstMemory *mem = gst_memory_new_wrapped(0, data, data_size, 0, data_size, (void*)ci, callback);
++      gst_buffer_append_memory(buf, mem);
++    }
++  }
++  GstClockTime finish_time = get_current_time();
++  fpgasrc->total_exec_time += (finish_time - start_time);
++  fpgasrc->prev_finish_time = finish_time;
++  fpgasrc->exec_count++;
++
++  GstClockTime running_time = get_current_time() - fpgasrc->start_time;
++  //clock_count += interval_in_nanosecdonss;
++  GST_BUFFER_PTS(buf) = running_time;
++  GST_BUFFER_TIMESTAMP(buf) = running_time;
++  GST_BUFFER_DTS(buf) = GST_CLOCK_TIME_NONE;
++#if 0
++  GST_BUFFER_DURATION(buf) = interval_in_nanosecdonss;
++#endif
++  gst_object_sync_values (GST_OBJECT (fpgasrc), GST_BUFFER_PTS (buf));
++  
++  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
++
+   return GST_FLOW_OK;
+ }
+ 
+diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.h a/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
+index 33e20e32..eb33582a 100644
+--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
++++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
+@@ -1,3 +1,7 @@
++/*****************************************************************
++ * Copyright 2024 NTT Corporation, FUJITSU LIMITED
++ *****************************************************************/
++
+ /* GStreamer
+  * Copyright (C) 2024 FIXME <fixme@example.com>
+  *
+@@ -33,10 +37,22 @@ G_BEGIN_DECLS
+ typedef struct _GstFpgasrc GstFpgasrc;
+ typedef struct _GstFpgasrcClass GstFpgasrcClass;
+ 
++#define DEBUG_TIMES 10
++
+ struct _GstFpgasrc
+ {
+   GstBaseSrc base_fpgasrc;
+ 
++  gboolean use_fpga;
++  gboolean config_fpga;
++  gint chid;
++  gint deqtcore;
++  GstClockTime start_time;
++  GstClockTime total_exec_time;
++  GstClockTime total_wait_time;
++  GstClockTime prev_finish_time;
++  GstClockTime total_debug_times[DEBUG_TIMES];
++  gint exec_count;
+ };
+ 
+ struct _GstFpgasrcClass
+diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch a/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch
+index 5e37be96..9d0e9958 100644
+--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch
++++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.patch
+@@ -0,0 +1,522 @@
++diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.c a/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
++index 1e3eb120..93ce553c 100644
++--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
+++++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.c
++@@ -1,3 +1,7 @@
+++/*****************************************************************
+++ * Copyright 2024 NTT Corporation, FUJITSU LIMITED
+++ *****************************************************************/
+++
++ /* GStreamer
++  * Copyright (C) 2024 FIXME <fixme@example.com>
++  *
++@@ -34,9 +38,16 @@
++ #include "config.h"
++ #endif
++ 
+++#define _GNU_SOURCE
+++
+++#include <assert.h>
+++#include <stdio.h>
+++
++ #include <gst/gst.h>
++ #include <gst/base/gstbasesrc.h>
++ #include "gstfpgasrc.h"
+++#include "liblogging.h"
+++#include "lib_worker.h"
++ 
++ GST_DEBUG_CATEGORY_STATIC (gst_fpgasrc_debug_category);
++ #define GST_CAT_DEFAULT gst_fpgasrc_debug_category
++@@ -79,7 +90,11 @@ static GstFlowReturn gst_fpgasrc_fill (GstBaseSrc * src, guint64 offset,
++ 
++ enum
++ {
++-  PROP_0
+++  PROP_0,
+++  PROP_USE_FPGA,
+++  PROP_CONFIG_FPGA,
+++  PROP_CHID,
+++  PROP_DEQTCORE
++ };
++ 
++ /* pad templates */
++@@ -88,9 +103,18 @@ static GstStaticPadTemplate gst_fpgasrc_src_template =
++ GST_STATIC_PAD_TEMPLATE ("src",
++     GST_PAD_SRC,
++     GST_PAD_ALWAYS,
++-    GST_STATIC_CAPS ("application/unknown")
+++    GST_STATIC_CAPS ("video/x-raw(ANY)")
++     );
++ 
+++extern struct data_size ds;
+++static char* fpga_dev;
+++static char* file_prefix;
+++char* connector_id;
+++bool debug_mode = false;
+++int ch_num;
+++static int ch_id;
+++static int cpu_id;
+++bool shmem_secondary = false;
++ 
++ /* class initialization */
++ 
++@@ -117,14 +141,17 @@ gst_fpgasrc_class_init (GstFpgasrcClass * klass)
++   gobject_class->get_property = gst_fpgasrc_get_property;
++   gobject_class->dispose = gst_fpgasrc_dispose;
++   gobject_class->finalize = gst_fpgasrc_finalize;
+++#if 0
++   base_src_class->get_caps = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_caps);
++   base_src_class->negotiate = GST_DEBUG_FUNCPTR (gst_fpgasrc_negotiate);
++   base_src_class->fixate = GST_DEBUG_FUNCPTR (gst_fpgasrc_fixate);
++   base_src_class->set_caps = GST_DEBUG_FUNCPTR (gst_fpgasrc_set_caps);
++   base_src_class->decide_allocation = GST_DEBUG_FUNCPTR (gst_fpgasrc_decide_allocation);
+++#endif
++   base_src_class->start = GST_DEBUG_FUNCPTR (gst_fpgasrc_start);
++   base_src_class->stop = GST_DEBUG_FUNCPTR (gst_fpgasrc_stop);
++   base_src_class->get_times = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_times);
+++#if 0
++   base_src_class->get_size = GST_DEBUG_FUNCPTR (gst_fpgasrc_get_size);
++   base_src_class->is_seekable = GST_DEBUG_FUNCPTR (gst_fpgasrc_is_seekable);
++   base_src_class->prepare_seek_segment = GST_DEBUG_FUNCPTR (gst_fpgasrc_prepare_seek_segment);
++@@ -135,13 +162,73 @@ gst_fpgasrc_class_init (GstFpgasrcClass * klass)
++   base_src_class->event = GST_DEBUG_FUNCPTR (gst_fpgasrc_event);
++   base_src_class->create = GST_DEBUG_FUNCPTR (gst_fpgasrc_create);
++   base_src_class->alloc = GST_DEBUG_FUNCPTR (gst_fpgasrc_alloc);
+++#endif
++   base_src_class->fill = GST_DEBUG_FUNCPTR (gst_fpgasrc_fill);
++ 
+++  /* define properties */
+++  g_object_class_install_property (gobject_class, PROP_USE_FPGA,
+++  g_param_spec_boolean ("use-fpga", "USE-FPGA",
+++			"Whether to use FPGA or not",
+++			FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+++  g_object_class_install_property (gobject_class, PROP_CONFIG_FPGA,
+++  g_param_spec_boolean ("config-fpga", "CONFIG-FPGA",
+++			"Whether to configure FPGA or not",
+++			FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+++  g_object_class_install_property (gobject_class, PROP_CHID,
+++  g_param_spec_int ("chid", "CHID",
+++		    "DMA channel ID",
+++		    0, 15, 0, G_PARAM_READWRITE));
+++  g_object_class_install_property (gobject_class, PROP_DEQTCORE,
+++  g_param_spec_int ("deqtcore", "DEQTCORE",
+++		    "CPU core to run dequeue thread on",
+++		    0, 31, 0, G_PARAM_READWRITE));
++ }
++ 
++ static void
++ gst_fpgasrc_init (GstFpgasrc *fpgasrc)
++ {
+++  gst_base_src_set_format (GST_BASE_SRC (fpgasrc), GST_FORMAT_TIME);
+++  gst_base_src_set_live (GST_BASE_SRC (fpgasrc), true);
+++
+++  int ret;
+++  int log_level;
+++  char *strenv;
+++  strenv = getenv("LOG_LEVEL");
+++  if (strenv == NULL) {
+++    log_level = LIBFPGA_LOG_INFO;
+++  } else {
+++    log_level = atoi(strenv);
+++  }
+++  libfpga_log_set_level(log_level);
+++
+++  strenv = getenv("FILE_PREFIX");
+++  if (strenv == NULL) {
+++    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FILE_PREFIX must be specified\n");
+++  }
+++  file_prefix = strenv;
+++
+++  strenv = getenv("SHMEM_SECONDARY");
+++  if (strenv != NULL && strcmp(strenv, "1") == 0) {
+++    log_libfpga(LIBFPGA_LOG_INFO,"start shmem secondary mode\n");
+++    shmem_secondary = true;
+++  }
+++
+++  cpu_set_t mask;
+++  size_t len = sizeof(mask);
+++  pid_t tid = gettid();
+++  CPU_ZERO(&mask);
+++  ret = sched_getaffinity(0, len, &mask);
+++  assert(ret == 0);
+++
+++  ret = init_mem(file_prefix, shmem_secondary);
+++  if (ret < 0) {
+++    log_libfpga(LIBFPGA_LOG_ERROR, "init_mem failed ret=%d\n", ret);
+++  }
+++  assert(ret == 0);
+++
+++  /* restore CPU mask */
+++  ret = sched_setaffinity(0, len, &mask);
+++  assert(ret == 0);
++ }
++ 
++ void
++@@ -153,7 +240,27 @@ gst_fpgasrc_set_property (GObject * object, guint property_id,
++   GST_DEBUG_OBJECT (fpgasrc, "set_property");
++ 
++   switch (property_id) {
++-    default:
+++  case PROP_USE_FPGA:
+++      fpgasrc->use_fpga = g_value_get_boolean (value);
+++      g_print ("use-fpga argument was changed to %s\n",
+++           fpgasrc->use_fpga ? "true" : "false");
+++      break;
+++  case PROP_CONFIG_FPGA:
+++      fpgasrc->config_fpga = g_value_get_boolean (value);
+++      g_print ("config-fpga argument was changed to %s\n",
+++           fpgasrc->config_fpga ? "true" : "false");
+++      break;
+++  case PROP_CHID:
+++      fpgasrc->chid = g_value_get_int (value);
+++      g_print ("chid argument was changed to %u\n",
+++           fpgasrc->chid);
+++      break;
+++  case PROP_DEQTCORE:
+++      fpgasrc->deqtcore = g_value_get_int (value);
+++      g_print ("deqtcore argument was changed to %u\n",
+++           fpgasrc->deqtcore);
+++      break;
+++  default:
++       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
++       break;
++   }
++@@ -168,7 +275,19 @@ gst_fpgasrc_get_property (GObject * object, guint property_id,
++   GST_DEBUG_OBJECT (fpgasrc, "get_property");
++ 
++   switch (property_id) {
++-    default:
+++  case PROP_USE_FPGA:
+++      g_value_set_boolean (value, fpgasrc->use_fpga);
+++      break;
+++  case PROP_CONFIG_FPGA:
+++      g_value_set_boolean (value, fpgasrc->config_fpga);
+++      break;
+++  case PROP_CHID:
+++      g_value_set_int (value, fpgasrc->chid);
+++      break;
+++  case PROP_DEQTCORE:
+++      g_value_set_int (value, fpgasrc->deqtcore);
+++      break;
+++  default:
++       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
++       break;
++   }
++@@ -257,20 +376,129 @@ gst_fpgasrc_decide_allocation (GstBaseSrc * src, GstQuery * query)
++ static gboolean
++ gst_fpgasrc_start (GstBaseSrc * src)
++ {
+++  int ret;
+++
+++  log_libfpga(LIBFPGA_LOG_INFO, "%s: start\n", __FUNCTION__);
+++
++   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
++ 
++   GST_DEBUG_OBJECT (fpgasrc, "start");
++ 
+++  char *strenv;
+++
+++  // required environment variables
+++
+++  strenv = getenv("FPGA_DEV");
+++  if (strenv == NULL) {
+++    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FPGA_DEV must be specified\n");
+++    return GST_FLOW_ERROR;
+++  }
+++  fpga_dev = strenv;
+++
+++  strenv = getenv("FILE_PREFIX");
+++  if (strenv == NULL) {
+++    log_libfpga(LIBFPGA_LOG_ERROR, "environment variable FILE_PREFIX must be specified\n");
+++    return GST_FLOW_ERROR;
+++  }
+++  file_prefix = strenv;
+++
+++  strenv = getenv("HEIGHT");
+++  if (strenv == NULL) {
+++    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable HEIGHT must be specified\n");
+++    return GST_FLOW_ERROR;
+++  }
+++  ds.output_height = atoi(strenv);
+++
+++  strenv = getenv("WIDTH");
+++  if (strenv == NULL) {
+++    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable WIDTH must be specified\n");
+++    return GST_FLOW_ERROR;
+++  }
+++  ds.output_width = atoi(strenv);
+++
+++  // debug mode
+++  strenv = getenv("DEBUG_MODE");
+++  if (strenv != NULL && strcmp(strenv, "1") == 0) {
+++    log_libfpga(LIBFPGA_LOG_INFO,"debug mode started\n");
+++    debug_mode = true;
+++    return TRUE;
+++  }
+++  strenv = getenv("CONNECTOR_ID");
+++  if (strenv == NULL) {
+++    log_libfpga(LIBFPGA_LOG_ERROR,"environment variable CONNECTOR_ID must be specified in worker-mode\n");
+++    return GST_FLOW_ERROR;
+++  }
+++  connector_id = strenv;
+++
+++  // optional environment variables
+++
+++  strenv = getenv("CPU_ID");
+++  if (strenv == NULL) {
+++    cpu_id = 0;
+++  } else {
+++    cpu_id = atoi(strenv);
+++  }
+++
+++  char ch_num_str[3];
+++  sprintf(ch_num_str, "%2d", 1);
+++
+++  // TODO: find free core
+++  //char deqtcore_name[3];
+++  //sprintf(deqtcore_name, "%2d", fpgasrc->deqtcore);
+++
+++  //GstClock clock;
+++  //gst_element_set_clock (GST_ELEMENT(fpgasrc), &clock);
+++
+++  ret = init_worker(fpga_dev, file_prefix, connector_id);
+++  if (ret < 0) {
+++    return GST_FLOW_ERROR;
+++  }
+++  cpu_set_t mask;
+++  size_t len = sizeof(mask);
+++  pid_t tid = gettid();
+++  CPU_ZERO(&mask);
+++  CPU_SET(cpu_id, &mask);
+++  ret = sched_setaffinity(0, len, &mask);
+++  assert(ret == 0);
+++  ret = sched_getaffinity(0, len, &mask);
+++  assert(ret == 0);
+++  log_libfpga(LIBFPGA_LOG_INFO, "tid %d's affinity = %08lx\n", tid, *(unsigned long*)mask.__bits);
+++  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
+++
+++  fpgasrc->start_time = get_current_time();
+++  fpgasrc->total_exec_time = 0;
+++  fpgasrc->total_wait_time = 0;
+++  for (int i = 0; i < DEBUG_TIMES; i++) {
+++    fpgasrc->total_debug_times[i] = 0;
+++  }
+++  fpgasrc->prev_finish_time = 0;
+++  fpgasrc->exec_count = 0;
++   return TRUE;
++ }
++ 
++ static gboolean
++ gst_fpgasrc_stop (GstBaseSrc * src)
++ {
+++  int ret;
+++
+++  if (debug_mode) {
+++    log_libfpga(LIBFPGA_LOG_INFO, "debug mode finished\n");
+++    return TRUE;
+++  }
+++
+++  log_libfpga(LIBFPGA_LOG_INFO, "%s start\n", __FUNCTION__);
+++
++   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
++ 
++   GST_DEBUG_OBJECT (fpgasrc, "stop");
++ 
+++  ret = finish_worker();
+++  if (ret < 0) {
+++    return GST_FLOW_ERROR;
+++  }
+++
+++  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
+++
++   return TRUE;
++ }
++ 
++@@ -282,6 +510,9 @@ gst_fpgasrc_get_times (GstBaseSrc * src, GstBuffer * buffer,
++ {
++   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
++ 
+++  *start = GST_BUFFER_PTS(buffer);
+++  *end = *start + GST_BUFFER_DURATION(buffer);
+++
++   GST_DEBUG_OBJECT (fpgasrc, "get_times");
++ 
++ }
++@@ -403,14 +634,142 @@ gst_fpgasrc_alloc (GstBaseSrc * src, guint64 offset, guint size,
++   return GST_FLOW_OK;
++ }
++ 
+++struct callback_info {
+++  uint32_t cmd_idx;
+++};
+++
+++static void callback(void* data) {
+++  int rc;
+++  struct callback_info* ci = (struct callback_info*)data;
+++  log_libfpga (LIBFPGA_LOG_DEBUG, "%s: cmd_idx=%u\n", __FUNCTION__, ci->cmd_idx);
+++  rc = clear_buffer(ci->cmd_idx);
+++  if (rc < 0) {
+++    log_libfpga(LIBFPGA_LOG_WARN, "clear_buffer failed! ret=%d\n", rc);
+++  }
+++  free(data);
+++}
+++
+++static void debug_callback(void* data) {
+++  free(data);
+++}
+++
+++static bool connected = false;
+++static uint32_t cmd_idx = 0;
+++//static uint64_t clock_count = 0;
+++
++ /* ask the subclass to fill the buffer with data from offset and size */
++ static GstFlowReturn
++ gst_fpgasrc_fill (GstBaseSrc * src, guint64 offset, guint size, GstBuffer * buf)
++ {
+++  log_libfpga(LIBFPGA_LOG_INFO, "%s: start\n", __FUNCTION__);
++   GstFpgasrc *fpgasrc = GST_FPGASRC (src);
++ 
++   GST_DEBUG_OBJECT (fpgasrc, "fill");
++ 
+++  GstClockTime start_time = get_current_time();
+++  if (fpgasrc->prev_finish_time != 0) {
+++    fpgasrc->total_wait_time += (start_time - fpgasrc->prev_finish_time);
+++  }
+++
+++  int stats_interval = 10;
+++  if (fpgasrc->exec_count > 0 && fpgasrc->exec_count % stats_interval == 0) {
+++    log_libfpga(LIBFPGA_LOG_INFO, "stats: avg exec_time=%lu [ms],  avg wait_time=%lu [ms]\n",
+++	   fpgasrc->total_exec_time/(stats_interval*1UL*1000*1000),
+++	   fpgasrc->total_wait_time/(stats_interval*1UL*1000*1000)
+++	   );
+++    log_libfpga(LIBFPGA_LOG_INFO, "stats: avg read_buffer_time=%lu [ms]\n",
+++	   fpgasrc->total_debug_times[0]/(stats_interval*1UL*1000*1000)
+++	   );
+++    fpgasrc->total_exec_time = 0;
+++    fpgasrc->total_wait_time = 0;
+++    for (int i = 0; i < DEBUG_TIMES; i++) {
+++      fpgasrc->total_debug_times[i] = 0;
+++    }
+++  }
+++
+++  gst_buffer_remove_all_memory(buf);
+++
+++  int framerate = 30;
+++  uint64_t interval_in_nanosecdonss = 1UL*1000*1000*1000 / framerate;
+++
+++  if (debug_mode) {
+++
+++    unsigned long time = 300;
+++    if (start_time - fpgasrc->start_time > 1UL*1000*1000*1000*time ) {
+++      log_libfpga(LIBFPGA_LOG_INFO, "written for %lu [sec] at %d [fps] in debug-mode!\n", time, framerate);
+++      return GST_FLOW_EOS;
+++    }
+++    int size = ds.output_width * ds.output_height * 3;
+++    void* data = malloc(size);
+++    memset(data, 0xFF, size);
+++    GstMemory *mem = gst_memory_new_wrapped(0, data, size, 0, size, data, debug_callback);
+++    gst_buffer_append_memory(buf, mem);
+++    log_libfpga(LIBFPGA_LOG_INFO, "debug_mode: data of size %d generated!\n", size);
+++    usleep(interval_in_nanosecdonss/1000);
+++    GstClockTime running_time = get_current_time() - fpgasrc->start_time;
+++    //clock_count += interval_in_nanosecdonss;
+++    GST_BUFFER_PTS(buf) = running_time;
+++    GST_BUFFER_TIMESTAMP(buf) = running_time;
+++    GST_BUFFER_DTS(buf) = GST_CLOCK_TIME_NONE;
+++#if 0
+++    GST_BUFFER_DURATION(buf) = interval_in_nanosecdonss;
+++#endif
+++    gst_object_sync_values (GST_OBJECT (fpgasrc), GST_BUFFER_PTS (buf));
+++    return GST_FLOW_OK;
+++  }
+++
+++  void* data;
+++  int data_size;
+++  int next_cmd_idx;
+++  struct callback_info* ci;
+++  unsigned long read_buffer_start_time = get_current_time();
+++  next_cmd_idx = read_buffer(cmd_idx, &data, &data_size);
+++  unsigned long read_buffer_finish_time = get_current_time();
+++  fpgasrc->total_debug_times[0] += (read_buffer_finish_time - read_buffer_start_time);
+++  if (next_cmd_idx == -1) {
+++    // timeout
+++    log_libfpga(LIBFPGA_LOG_WARN, "create dummy data, size = (%d, %d)\n", ds.output_width, ds.output_height);
+++    int dummy_data_size = ds.output_width * ds.output_height * 3;
+++    void* dummy_data = malloc(dummy_data_size);
+++    memset(dummy_data, 0xFF, dummy_data_size);
+++    GstMemory *mem = gst_memory_new_wrapped(0, dummy_data, dummy_data_size, 0, dummy_data_size, dummy_data, debug_callback);
+++    gst_buffer_append_memory(buf, mem);
+++  } else {
+++    // received data
+++    ci = malloc(sizeof(struct callback_info));
+++    ci->cmd_idx = cmd_idx;
+++    cmd_idx = next_cmd_idx;
+++    if (data == NULL) {
+++      log_libfpga(LIBFPGA_LOG_WARN, "create dummy data, size = (%d, %d)\n", ds.output_width, ds.output_height);
+++      int dummy_data_size = ds.output_width * ds.output_height * 3;
+++      void* dummy_data = malloc(dummy_data_size);
+++      memset(dummy_data, 0x77, dummy_data_size);
+++      GstMemory *mem = gst_memory_new_wrapped(0, dummy_data, dummy_data_size, 0, dummy_data_size, dummy_data, debug_callback);
+++      gst_buffer_append_memory(buf, mem);
+++      // discard broken data right away
+++      callback((void*)ci);
+++    } else {
+++      GstMemory *mem = gst_memory_new_wrapped(0, data, data_size, 0, data_size, (void*)ci, callback);
+++      gst_buffer_append_memory(buf, mem);
+++    }
+++  }
+++  GstClockTime finish_time = get_current_time();
+++  fpgasrc->total_exec_time += (finish_time - start_time);
+++  fpgasrc->prev_finish_time = finish_time;
+++  fpgasrc->exec_count++;
+++
+++  GstClockTime running_time = get_current_time() - fpgasrc->start_time;
+++  //clock_count += interval_in_nanosecdonss;
+++  GST_BUFFER_PTS(buf) = running_time;
+++  GST_BUFFER_TIMESTAMP(buf) = running_time;
+++  GST_BUFFER_DTS(buf) = GST_CLOCK_TIME_NONE;
+++#if 0
+++  GST_BUFFER_DURATION(buf) = interval_in_nanosecdonss;
+++#endif
+++  gst_object_sync_values (GST_OBJECT (fpgasrc), GST_BUFFER_PTS (buf));
+++  
+++  log_libfpga(LIBFPGA_LOG_INFO, "%s: finish\n", __FUNCTION__);
+++
++   return GST_FLOW_OK;
++ }
++ 
++diff --git b/tools/fpga_plugins/fpgasrc/gstfpgasrc.h a/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
++index 33e20e32..eb33582a 100644
++--- b/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
+++++ a/tools/fpga_plugins/fpgasrc/gstfpgasrc.h
++@@ -1,3 +1,7 @@
+++/*****************************************************************
+++ * Copyright 2024 NTT Corporation, FUJITSU LIMITED
+++ *****************************************************************/
+++
++ /* GStreamer
++  * Copyright (C) 2024 FIXME <fixme@example.com>
++  *
++@@ -33,10 +37,22 @@ G_BEGIN_DECLS
++ typedef struct _GstFpgasrc GstFpgasrc;
++ typedef struct _GstFpgasrcClass GstFpgasrcClass;
++ 
+++#define DEBUG_TIMES 10
+++
++ struct _GstFpgasrc
++ {
++   GstBaseSrc base_fpgasrc;
++ 
+++  gboolean use_fpga;
+++  gboolean config_fpga;
+++  gint chid;
+++  gint deqtcore;
+++  GstClockTime start_time;
+++  GstClockTime total_exec_time;
+++  GstClockTime total_wait_time;
+++  GstClockTime prev_finish_time;
+++  GstClockTime total_debug_times[DEBUG_TIMES];
+++  gint exec_count;
++ };
++ 
++ struct _GstFpgasrcClass
